import numpy as np

lab = np.array([
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1],
[1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
[1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
[1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1],
[1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
[1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
[1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1],
[1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
[1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
[1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]])


start = (24,5)
end = (1,1)

def make_step(k): # 1. скан матрицы с помощью двойного цикла. 2. если стены нет, установите k+1 в эти ячейки.
  # пробег по x
  for i in range(len(lab_modifyed)):
    # пробег по y
    for j in range(len(lab_modifyed[i])):
      # перебор свободных клеток
      if lab_modifyed[i][j] == k:
        if i>0 and lab_modifyed[i-1][j] == 0 and lab[i-1][j] == 0:
          lab_modifyed[i-1][j] = k + 1
        if j>0 and lab_modifyed[i][j-1] == 0 and lab[i][j-1] == 0:
          lab_modifyed[i][j-1] = k + 1
        if i<len(lab_modifyed)-1 and lab_modifyed[i+1][j] == 0 and lab[i+1][j] == 0:
          lab_modifyed[i+1][j] = k + 1
        if j<len(lab_modifyed[i])-1 and lab_modifyed[i][j+1] == 0 and lab[i][j+1] == 0:
          lab_modifyed[i][j+1] = k + 1



lab_modifyed = []
# заполнение матрицы-клона лабиринта нулями, постановка шага 1 в стартовую точку 
for i in range(len(lab)):
    lab_modifyed.append([])
    for j in range(len(lab[i])):
        lab_modifyed[-1].append(0)
i,j = start
lab_modifyed[i][j] = 1

# отметка шагов 
k = 0
while lab_modifyed[end[0]][end[1]] == 0:
    k += 1
    make_step(k)  

# заполнение списка с координатами кратчайшего пути
i, j = end
k = lab_modifyed[i][j]
the_path = [(i,j)]
# отметка шагов
while k > 1:
  # проверка корректности шага  !не то, правильно будет проверка соседних клеток, в которых значение шага меньше на один.
  if i > 0 and lab_modifyed[i - 1][j] == k-1:
    i, j = i-1, j
    the_path.append((i, j))
    k-=1
  elif j > 0 and lab_modifyed[i][j - 1] == k-1:
    i, j = i, j-1
    the_path.append((i, j))
    k-=1
  elif i < len(lab_modifyed) - 1 and lab_modifyed[i + 1][j] == k-1:
    i, j = i+1, j
    the_path.append((i, j))
    k-=1
  elif j < len(lab_modifyed[i]) - 1 and lab_modifyed[i][j + 1] == k-1:
    i, j = i, j+1
    the_path.append((i, j))
    k -= 1

the_path.reverse()

print(the_path)
# by alwwwd